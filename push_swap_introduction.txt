							Пролог:
	В этом текстовом файле я буду описывать свои первые мысли и сухие идеи, основанные на том, что я смог запомнить и понять из того,
 что мне рассказала Гузель. Я еще даже не начал писать код:) Как и вы, наверное, но с чего-то же надо начать, родить идею для быстрой 
сортировки трудновато, поэтому Peer-to-peer как никогда полезен.

					Сочинение на тему: "Push_swap , а не Swap_push".
							Введение: 
	Мы должны понять, в чем заключается задача этого проекта. Простыми словами нам необходимо отсортировать стек чисел,
 который нам пришел. Отсортировать - значит выставить в порядке возрастания. Сложность этого проекта состоит в том, что сортировка должна 
происходить за как можно меньше кол-во разрешенных нам команд. Про команды писать не буду, они отлично описаны в сабджикте.
						Подготовка к работе: 
	Необходимо провести проверку валидности пришедших нам значений. Стек приходит нам в виде дополнительных параметров при запуске
 программы, типо: 

	./push_swap <число1> <число2> ...

	То есть изначально стек будет приходить к нам в виде массива из строк, в виде параметра нашего мейника, типо:

	int main(int argc, char **argv);

	Для удобства мы конвертируем этот массив строк в массив чисел при помощи обычного цикла и библиотечного ft_atoi. Если атои выдаст 
ошибку, значит к нам пришло не число. Дальше с этими числами проведем проверку на уникальность и вхождения в пределы int.
	Структура нашего списка: чтобы не пришлось передавать по миллион параметров в наши будущие функции, удобно использовать структуру,
 из которой мы в будущем сформируем два-связанный список, прототип нашей структуры будет выглядеть так:

typedef struct v_vars
{
	int	true_index;
	int	local_stack;
	int	range;
	int	direction;
	int	value;
	int	keep_in_stack
}	t_vars;

	О значении каждого параметра я расскажу во время описании метода сортировки, а сейчас нужно знать только, 
что value - это численное значение числа, то есть у "2" value = 2,  у "123"  value = 123 и тд.
	 				Начало работы: 
				Этап I: "Настоящий индекс числа"
	Сейчас все, что у нас есть - это не рассортированный массив данными нам числами. Как бы это странно странно не звучало, но нам 
необходимо знать как будет выглядеть отсортированный стек, то есть знать на каком месте от начала будет стоять определенное число, 
например, нам пришел стек чисел "32 4 6 12", когда мы отсортируем этот список он будет выглядеть так: 
"4 6 12 32", то есть 4 будет на месте месте, 6 на втором месте и тд, это значение нам необходимо сохранить в параметре true_index.
				Этап II: "длинна локального стека"
	Введем такое понятие как "локальный стек" -  это будет набор уже отсортированных чисел, но только на основе начального положения 
основного стека причем для каждого числа он будет свой. Звучит супер непонятно, потому что я не умею описывать), но это реально сложно, 
легче показать пример. Пусть нам поступили числа "2 5 7 12 3 56 8 44". Начинаем с самого первого числа - 2, сравниваем его со 
следующим - 5, 5 больше 2? -  ДА, значит 5 входит в локальный стек и теперь мы будем сравнивать числа с ним. 7 больше 5? - ДА,
 действия аналогичные с 5. 12 больше 7 - ДА, аналогичные действия, 3 больше 12? - НЕТ, 3 не входит в локальный стек, просто идем дальше.
 56 больше 12? -ДА, 8 больше 56? - НЕТ, 44 больше 56? - НЕТ, мы прошит все числа, именно ПРОШЛИ ВСЕ ЧИСЛА, с начала до конца, 
а не просто стек кончился на последнем числе, это важно так как, например, для второго числа сперва мы также будет идти по списку направо,
 а потом вернемся к первому числу, это и значит "ПРОШЛИ ВСЕ ЧИСЛА", идти необходимо только как описано раньше. Для первого числа - 2 ,
 сформировался локальный стек: "2 5 7 12 56", в переменную local_stack нам необходимо записать его длину, то есть - 5.
 Находим и записываем длинны локальных стеков для каждого числа.
				Этап III: "перекидывание во второй стек"
	Я не говорил об этом, но вы могли слышать о том, что у нас на самом деле есть два, бы реальных стеков с числами, назовем их "a" & "б"
(Нереальными стеками я называю -  локальные стеки). Изначально стек "а" будет заполнен всеми нашими числами, а стек "б" - пустой, 
наши команды позволяют работать с этими стеками (внимательно разберитесь с командами для стеков,  буду использовать некоторые понятие из них,
 не объясняя).
	Нам необходимо перекинуть некоторые числа из стека "а"  в стек "б", но какие именно? Мы знаем длинны локальных стеков для всех чисел,
 вот надо оставить в стеке "а" только те числа, которые входят в локальный стек с самой большой длинной( если есть два стека с одинаковой
 длинной, выбираем тот, который принадлежит числу с большим значением). Выбрав это число, надо будет запустить функцию, которая присвоен
 для чисел, входящих в этот локальный стек в поле keep_in_stack = 1, для не входящих значение keep_in_stack = 0. Зная какие числа надо 
оставить переносим их ,используя команды "pa" & "ra". Для примера со второго этапа наши стеки должны выглядеть так:
 a = {2 5 7 12 56},  б = {44 8 3}.
				Этап IV: "короткий путь"
	На следущих этапах нам придется возвращать числа из стека "б" в стек "а", но уже в правильном порядке. Для этого  мы будем использовать определенные правила,
но у них ограничени в том, что перекидывать мы сможем только первые элементы, поэтому сначала необходимо перенести нужный нам элемент в начало, а потом уже только перекинуть.
Для элементов есть два путя к первому слоту стека, на прямую подниматся или через "задний ход". Так как нам необходимо использовать как можно 
меньше команда, для нас это принципиально. Очевидно, что для чисел находящихся в начальной половине короче будет путь на прямую, а для второй половине через
"задний ход". Нам необходимо вызвать функцию, которая присвоит для direction = 1, для вторых direction = 0. Причем это необходимо для обоих стеков,
потом узнаете почему!
				Этап V: "длинна пути"
	Длинна пути - это число команд которое будет необходимо, чтобы элемент переместился на первый слот по короткому пути. Необходимо вызвать функцию,
которая запишет это необходимое число в команд в поле range. Также проделываем это для обоих стеков.
					Сортировка:
Очевидно что стек отсортируется тогда, когда элементы будут лежать в порядке возростния их true_index. Допустим в стаке "а" есть число с индексом n, а
в стаке "б"  с индексом n - 1, тогда сумма их range + 1 будет число команд необходимое для того чтобы число с индексом встало на правильное место в стаке "а"
(+ 1 потому что еще нужно перенести его). Для каждого числа из стака "а" находим это число, выбераем самое маленькое(если два одинаковых выбираем то, у которого число из стака "б"
стоит ближе к началу). Исполняем эти команды, потом пересчитываем direction & range для нового положения чисел в стеках. Продолжаем перекидывать числа, до того момента
пока в стаке "б" не останется элентов.
					Заключение:
Очевидно , что каждый раз когда мы выполняли какие-либо команды, нужно было просто выводить их название в консоль:)
P.S. Я не знаю насколько эффективен этод метод, но Гузель сказал, что он на все 100%
P.P.S возмлжно стоит еще стоит добавить такие парамерты как: full-range(сумма путей) и index(текущий индекс числа в стеке)
P.P.P.S Спасибо Гузель! 